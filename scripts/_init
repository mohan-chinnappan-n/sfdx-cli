#!/usr/bin/env bash

# shellcheck disable=SC2034

# Fail wait when any children fails
set -m

set -o errexit
set -o pipefail
set -o nounset
# set -o xtrace

PATH="node_modules/.bin:$PATH"

# Set magic root dir from current file
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)"
cd "$ROOT_DIR"

function stderr() {
    set +x
    echo "$@" 1>&2
    set -x
}

function stdout() {
    set +x
    echo "$@"
    set -x
}

function script () {
    name="$1"
    shift
    "$ROOT_DIR/scripts/$name" "$@"
}

function sha() {
    if [[ -x "$(command -v shasum)" ]]; then
        digest=$(shasum -a 256 < "$1" | awk '{print $1}')
    elif [[ -x "$(command -v sha256sum)" ]]; then
        digest=$(sha256sum < "$1" | awk '{print $1}')
    elif [[ -x "$(command -v openssl)" ]]; then
        # Use sed to portably strip the "(stdin)= " prefix present on some systems
        digest=$(openssl dgst -sha256 < "$1" | sed 's/^.* //')
    else
        stderr "No command found to generate sha256 sums"
        exit 1
    fi
    echo "$digest"
}

function len() {
    echo ${#1}
}

function archs () {
    if [[ "$OS" == "darwin" ]]; then
        echo "x64"
    elif [[ "$OS" == "windows" ]]; then
        echo "x64|x86"
    elif [[ "$OS" == "linux" ]]; then
        echo "x64|x86|arm"
    fi
}

function setos () {
    export OS="$1"
    if [[ ! -z "${ARCH:-}" ]]; then
        setarch "$ARCH"
    fi
}

function setarch () {
    export ARCH="$1"
    export VERSIONED_BASE="${PKG_NAME}-v${VERSION}-${OS}-${ARCH}"
    export UNVERSIONED_BASE="${PKG_NAME}-${OS}-${ARCH}"
    export WORKSPACE_DIR="$TMP_DIR/${OS}_${ARCH}"
    export TGZ_PATH="$RELEASE_DIR/$UNVERSIONED_BASE.tar.gz"
    export TXZ_PATH="$RELEASE_DIR/$UNVERSIONED_BASE.tar.xz"

    if [[ "$OS" = "linux" ]]; then
        if [[ "$ARCH" = "x64" ]]; then
            export DEB_ARCH="amd64"
        elif [[ "$ARCH" = "x86" ]]; then
            export DEB_ARCH="i386"
        elif [[ "$ARCH" = "arm" ]]; then
            export DEB_ARCH="armel"
        fi
        export VERSIONED_DEB_BASE="${BIN_NAME}_${DEB_VERSION}_$DEB_ARCH"
        export UNVERSIONED_DEB_BASE="${BIN_NAME}_$DEB_ARCH"
        export VERSIONED_DEB_PATH="$RELEASE_APT_DIR/$VERSIONED_DEB_BASE.deb"
        export UNVERSIONED_DEB_PATH="$RELEASE_APT_DIR/$UNVERSIONED_DEB_BASE.deb"
    fi
}

function bg () {
    "$@" &
    pids="${pids:-} $!"
}

function wait_all () {
    for pid in $pids; do
        wait "${pid}" || exit 1
    done
}

GITHUB_BASE_URL="https://git.soma.salesforce.com/api/v3/repos/salesforcedx/cli"

ghQueryRelease() {
    TAG="v$SHORT_VERSION"

    set +x
    RELEASE_JSON=$(curl -sSL -H "Accept: application/vnd.github.v3+json" "$GITHUB_BASE_URL/releases/tags/$TAG?access_token=$GIT_TOKEN")
    set -x

    MESSAGE=$(echo "$RELEASE_JSON" | node -e "require('$ROOT_DIR/scripts/transform')((json)=>json.message)")
    if [[ "$MESSAGE" == "Not Found" ]]; then
        set +x
        RELEASE_JSON=$(curl -X POST -H "Content-Type: application/vnd.github.v3+json" -d "{\"tag_name\":\"$TAG\"}" "$GITHUB_BASE_URL/releases?name=$UPLOAD_FILE_NAME&access_token=$GIT_TOKEN")
        set -x
    fi

    stdout "$RELEASE_JSON"
}

ghAssetUrl() {
    RELEASE_JSON="$1"
    ASSET="$2"
    echo "$RELEASE_JSON" | node -e "require('$ROOT_DIR/scripts/transform')((json)=>(json.assets.filter((a)=>a.name==='$ASSET')[0]||{}).url||'')"
}

ghUploadUrl() {
    RELEASE_JSON="$1"
    echo "$RELEASE_JSON" | node -e "require('$ROOT_DIR/scripts/transform')((json)=>json.upload_url.split('{')[0])"
}

ghUploadAsset() {
    UPLOAD_FILE_PATH="$1"
    UPLOAD_FILE_NAME="$2"
    stdout "Querying github release $TAG"
    RELEASE_JSON=$(ghQueryRelease)
    ASSET_URL=$(ghAssetUrl "$RELEASE_JSON" "$UPLOAD_FILE_NAME")

    if [[ ! -z "${ASSET_URL}" ]]; then
        stdout "Deleting existing github release asset $UPLOAD_FILE_NAME at $ASSET_URL"
        set +x
        curl -X DELETE "$ASSET_URL?access_token=$GIT_TOKEN"
        set -x
    fi

    UPLOAD_URL=$(ghUploadUrl "$RELEASE_JSON")

    stdout "Uploading github release asset $UPLOAD_FILE_NAME to $UPLOAD_URL"
    set +x
    curl -X POST --data-binary "@$UPLOAD_FILE_PATH" -H "Content-Type: application/octet-stream" "$UPLOAD_URL?name=$UPLOAD_FILE_NAME&access_token=$GIT_TOKEN"
    set -x
}

ghDownloadAsset() {
    DOWNLOAD_FILE_NAME="$1"
    stdout "Querying github release $TAG"
    RELEASE_JSON=$(ghQueryRelease)
    ASSET_URL=$(ghAssetUrl "$RELEASE_JSON" "$DOWNLOAD_FILE_NAME")

    stdout "Downloading github release asset $DOWNLOAD_FILE_NAME from $ASSET_URL"
    set +x
    curl -L -H "Accept: application/octet-stream" "$ASSET_URL?access_token=$GIT_TOKEN" | tar xz
    set -x
}

# Set channel and version vars
CHANNEL=$(script "_vars/channel")
VERSION=$(script "_vars/version")
SHORT_VERSION=$(node -p "require('$ROOT_DIR/package.json').version")
DEB_VERSION="${SHORT_VERSION}-1"

# Set basic dir vars
TMP_DIR="$ROOT_DIR/tmp"
BASE_DIR="$TMP_DIR/base"
RELEASE_DIR="$ROOT_DIR/release"
RESOURCES_DIR="$ROOT_DIR/resources"
RELEASE_VERSION_DIR="$RELEASE_DIR/v$VERSION"
RELEASE_APT_DIR="$RELEASE_DIR/apt"

# Determine pkg and bin names
PKG_NAME=$(node -p "require('$ROOT_DIR/package.json').name")
PKG_DESC=$(node -p "require('$ROOT_DIR/package.json').description")
BIN_NAME=$(node -p "require('$ROOT_DIR/package.json')['cli-engine'].bin")

# S3 configuration
DEFAULT_S3_FOLDER=$(node -p "require('$ROOT_DIR/package.json')['cli-engine'].s3.folder")
S3_FOLDER="${S3_FOLDER:-"$DEFAULT_S3_FOLDER"}"
S3_CHANNEL_SUBFOLDER="$PKG_NAME/channels/$CHANNEL"
DEFAULT_S3_BUCKET=$(node -p "require('$ROOT_DIR/package.json')['cli-engine'].s3.bucket")
S3_BUCKET="${S3_BUCKET:-"$DEFAULT_S3_BUCKET"}"
S3_BASE_UPLOAD_URL="s3://$S3_BUCKET/$S3_FOLDER"
S3_CHANNEL_UPLOAD_URL="$S3_BASE_UPLOAD_URL/$S3_CHANNEL_SUBFOLDER"
DEFAULT_S3_HOST=$(node -p "require('$ROOT_DIR/package.json')['cli-engine'].s3.host")
S3_HOST="${S3_HOST:-"$DEFAULT_S3_HOST"}"
S3_HOST_SCHEME="${S3_HOST_SCHEME:-"https"}"
S3_HOST_BASE_URL="$S3_HOST_SCHEME://$S3_HOST/$S3_CHANNEL_SUBFOLDER"
S3_PROFILE_NAME="sfdx"
S3_ENDPOINT="${S3_ENDPOINT:-AWS}"

# Set OS targets
OS_TARGETS=(
    "darwin"
    "linux"
    "windows"
)

if [[ ! -z "${OS:-}" ]]; then
    setos "$OS"
    IFS='|' read -ra ARCHS <<< "$(archs)"
fi

INSTALLER_BASE_NAME="$PKG_NAME-v$VERSION"
